/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f401xc.h"
#include "boardDefs.h"
#include <stdlib.h>

void setup_timer(TIM_TypeDef*);
void enable_timer(TIM_TypeDef*);
uint32_t float_to_servo(float);

TIM_TypeDef *Timers[] = {TIM1, TIM2, TIM3, TIM4};
uint32_t *CCR_Registers[] = {
		  &TIM1->CCR1, &TIM1->CCR2, &TIM1->CCR3, &TIM1->CCR4,
		  &TIM2->CCR1, &TIM2->CCR2, &TIM2->CCR3, &TIM2->CCR4,
		  &TIM3->CCR1, &TIM3->CCR2, &TIM3->CCR3, &TIM3->CCR4,
		  &TIM4->CCR1, &TIM4->CCR2, &TIM4->CCR3, &TIM4->CCR4};
volatile uint8_t* i2c_data;
volatile uint8_t i2c_index = 0;

int main(void)
{
	/*
	 * timers to set up:
	 * 	tim1 <advanced>
	 * 	tim2 <general>
	 * 	tim3 <general>
	 * 	tim4 <general>
	 */
	i2c_data = calloc(16, sizeof(uint8_t));
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN;
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN | RCC_APB1ENR_TIM3EN | RCC_APB1ENR_TIM4EN | RCC_APB1ENR_I2C2EN;
	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN | RCC_APB2ENR_TIM9EN;
	for(int i=0; i<16; i++){
		*CCR_Registers[i] = float_to_servo(i2c_data[i]/255.0f);
	}
	for(int i=0; i<4; i++){
		setup_timer(Timers[i]);
	}
	/*
	 * GPIOA
	 * 	0-3 AF1 (TIM2 output)
	 * 	6-7 AF2 (TIM3 output)
	 * 	11 AF1 (TIM1 output)
	 */
	GPIOA->AFR[0] = 1 << GPIO_AFRL_AFSEL0_Pos | 1 << GPIO_AFRL_AFSEL1_Pos | 1 << GPIO_AFRL_AFSEL2_Pos | 1 << GPIO_AFRL_AFSEL3_Pos |
			2 << GPIO_AFRL_AFSEL6_Pos | 2 << GPIO_AFRL_AFSEL7_Pos;
	GPIOA->AFR[1] = 1 << GPIO_AFRH_AFSEL11_Pos;
	GPIOA->MODER |= 2 << GPIO_MODER_MODER0_Pos | 2 << GPIO_MODER_MODER1_Pos | 2 << GPIO_MODER_MODER2_Pos | 2 << GPIO_MODER_MODER3_Pos |
			2 << GPIO_MODER_MODER6_Pos | 2 << GPIO_MODER_MODER7_Pos |
			2 << GPIO_MODER_MODER11_Pos;
	/*
	 * GPIOB
	 * 	0-1 AF2 (TIM3 output)
	 * 	3 AF9 (I2C input)
	 * 	6-9 AF2 (TIM4 output)
	 * 	10 AF4 (I2C input)
	 * 	13-15 AF1 (TIM1 output)
	 */
	GPIOB->AFR[0] |= 2 << GPIO_AFRL_AFSEL0_Pos | 2 << GPIO_AFRL_AFSEL1_Pos |
			9 << GPIO_AFRL_AFSEL3_Pos |
			2 << GPIO_AFRL_AFSEL6_Pos | 2 << GPIO_AFRL_AFSEL7_Pos;
	GPIOB->AFR[1] = 2 << GPIO_AFRH_AFSEL8_Pos |2 << GPIO_AFRH_AFSEL9_Pos |
			4 << GPIO_AFRH_AFSEL10_Pos |
			1 << GPIO_AFRH_AFSEL13_Pos | 1 << GPIO_AFRH_AFSEL14_Pos | 1 << GPIO_AFRH_AFSEL15_Pos;
	GPIOB->MODER |= 2 << GPIO_MODER_MODER0_Pos | 2 << GPIO_MODER_MODER1_Pos |
			2 << GPIO_MODER_MODER3_Pos |
			2 << GPIO_MODER_MODER6_Pos | 2 << GPIO_MODER_MODER7_Pos | 2 << GPIO_MODER_MODER8_Pos | 2 << GPIO_MODER_MODER9_Pos |
			2 << GPIO_MODER_MODER10_Pos |
			2 << GPIO_MODER_MODER13_Pos | 2 << GPIO_MODER_MODER14_Pos | 2 << GPIO_MODER_MODER15_Pos;
	GPIOB->OTYPER |= GPIO_OTYPER_OT3 | GPIO_OTYPER_OT10;
	GPIOB->OSPEEDR |= 3 << GPIO_OSPEEDR_OSPEED3_Pos | 3 << GPIO_OSPEEDR_OSPEED10_Pos;
	GPIOB->PUPDR |= 1 << GPIO_PUPDR_PUPD3_Pos | 1 << GPIO_PUPDR_PUPD10_Pos;
	//special setup for TIM1
	TIM1->BDTR = TIM_BDTR_MOE;
	TIM1->CCER = TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE | TIM_CCER_CC4E;// | TIM_CCER_CC1NP | TIM_CCER_CC2NP | TIM_CCER_CC3NP;
	TIM1->PSC = 27;

	//setup TIM9 for internal interrupting
	TIM9->ARR = 59999;
	TIM9->PSC = 111;
	TIM9->DIER = TIM_DIER_UIE;
	NVIC_SetPriority(TIM1_BRK_TIM9_IRQn, 1);
	NVIC_EnableIRQ(TIM1_BRK_TIM9_IRQn);

	for(int i=0; i<4; i++){
		enable_timer(Timers[i]);
	}

	/*
	 * now for I2C setup
	 * 	GPIO and clocks are already done
	 */
	I2C2->CR1 = I2C_CR1_SWRST;
	I2C2->CR1 = 0;
	I2C2->CR1 = I2C_CR1_NOSTRETCH;
	I2C2->CR2 = 42 << I2C_CR2_FREQ_Pos | I2C_CR2_ITEVTEN;
	I2C2->OAR1 = I2C_ADDRESS << I2C_OAR1_ADD1_Pos;
	I2C2->CR1 |= I2C_CR1_PE;
	I2C2->CR1 |= I2C_CR1_ACK;
	NVIC_SetPriority(I2C2_EV_IRQn, 2);
	NVIC_EnableIRQ(I2C2_EV_IRQn);
	__enable_irq();

	TIM9->CR1 |= TIM_CR1_CEN;

	while(1){

	}

}

void setup_timer(TIM_TypeDef* timer){
	//84mhz input -> 50hz output PSK of 28, 60K ARR
	timer->ARR = 59999;
	timer->CCMR1 = 6 << TIM_CCMR1_OC1M_Pos | TIM_CCMR1_OC1PE | 6 << TIM_CCMR1_OC2M_Pos | TIM_CCMR1_OC2PE;
	timer->CCMR2 = 6 << TIM_CCMR2_OC3M_Pos | TIM_CCMR2_OC3PE | 6 << TIM_CCMR2_OC4M_Pos | TIM_CCMR2_OC4PE;
	timer->PSC = 13;
	timer->CCER = TIM_CCER_CC1E | TIM_CCER_CC2E | TIM_CCER_CC3E | TIM_CCER_CC4E;
}

void enable_timer(TIM_TypeDef* timer){
	timer->CR1 = TIM_CR1_CEN;
}

uint32_t float_to_servo(float value){
	if(value > 1.0f){
		value = 1.0f;
	}
	if(value < 0.0f){
		value = 0.0f;
	}
	return 1500 + (unsigned int)(6000 * value);
}

void I2C2_EV_IRQHandler(void){
	if(I2C2->SR1 & I2C_SR1_ADDR){
		uint32_t read = I2C2->SR2;
		return;
	}
	if(I2C2->SR1 & I2C_SR1_RXNE){
		i2c_data[i2c_index] = I2C2->DR;
		i2c_index ++;
		if(i2c_index >= 16){
			for(int i=0; i<16; i++){
				*CCR_Registers[i] = float_to_servo(i2c_data[i]/255.0f);
			}
			i2c_index = 0;
		}
		TIM9->CNT = 0;
		return;
	}
	if(I2C2->SR1 & I2C_SR1_STOPF || I2C2->SR1 & I2C_SR1_OVR){
		I2C2->SR1 = 0;
	}
}

void TIM1_BRK_TIM9_IRQHandler(void){
	TIM9->SR = 0;
	i2c_index = 0;
}
